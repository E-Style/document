# 黑马优购



## 1. 项目介绍

首页、分类、搜索、商品列表、商品详情、购物车、支付



## 2. 初始化项目

### 2.1 初始化项目

1. 运行 `wepy init standard heima_ugo` 命令，初始化小程序项目
2. 运行 `cd heima_ugo` 进入项目根目录
3. 运行 `npm install` 安装所有依赖项
4. 运行 `wepy build --watch` 命令，开启 wepy 项目的实时编译功能
5. 打开微信开发者工具，加载 wepy 项目并查看效果
6. 解决 ESLint 语法报错问题

### 2.2 梳理项目结构

1. 清理并重置 `src -> pages -> index.wpy` 首页
2. 在根目录的 `.prettierrc` 配置文件内，新增 `"semi": false` 配置，防止每次格式化代码，添加分号的问题
3. 清理并重置 `src -> app.wpy` 中的代码，将 `style` 和 `script` 标签中，不必要的代码删除掉
4. 清空 `src -> components` 和 `src -> mixins` 目录
5. 将梳理完毕后的项目，上传至码云

### 2.3 绘制 tabBar

1. 新建 `src -> pages -> tabs` 文件夹，用来存放所有 tabBar 相关的页面

2. 删除 `src -> pages -> index.wpy` 页面，并在 `tabs` 目录中，新建 `home.wpy`，`cates.wpy`，`search.wpy`，`cart.wpy`，`me.wpy` 五个 tabBar 相关的页面

3. 将页面路径，记录到 `src -> app.wpy` 文件的 `config -> pages` 节点中，示例代码如下：

   ```js
   pages: [
     'pages/tabs/home',
     'pages/tabs/cates',
     'pages/tabs/search',
     'pages/tabs/cart',
     'pages/tabs/me'
   ]
   ```

4. 新建 `src -> assets` 目录，并将素材中的 `icons` 文件夹，拷贝到项目 `src -> assets` 目录中

5. 在 `src -> app.wpy` 文件中，新增 `tabBar` 节点，并做如下配置：

   ```js
   tabBar: {
     // 选中的文本颜色
     selectedColor: '#D81E06',
     // tabBar 的列表
     list: [
       {
         // 页面路径
         pagePath: 'pages/tabs/home',
         // 显示的文本
         text: '首页',
         // 默认图标
         iconPath: '/assets/icons/home.png',
         // 选中图标
         selectedIconPath: '/assets/icons/home-active.png'
       },
       {
         pagePath: 'pages/tabs/cates',
         text: '分类',
         iconPath: '/assets/icons/cates.png',
         selectedIconPath: '/assets/icons/cates-active.png'
       },
       {
         pagePath: 'pages/tabs/search',
         text: '搜索',
         iconPath: '/assets/icons/search.png',
         selectedIconPath: '/assets/icons/search-active.png'
       },
       {
         pagePath: 'pages/tabs/cart',
         text: '购物车',
         iconPath: '/assets/icons/cart.png',
         selectedIconPath: '/assets/icons/cart-active.png'
       },
       {
         pagePath: 'pages/tabs/me',
         text: '我的',
         iconPath: '/assets/icons/my.png',
         selectedIconPath: '/assets/icons/my-active.png'
       }
     ]
   }
   ```

### 2.4 修改导航栏样式

打开 `src -> app.wpy` 文件，找到 `window` 节点，并配置如下：

```js
window: {
  // 页面背景色
  backgroundTextStyle: 'dark',
  // 导航条背景色
  navigationBarBackgroundColor: '#D81E06',
  // 导航条标题文本
  navigationBarTitleText: '黑马优购',
  // 导航条标题文字颜色
  navigationBarTextStyle: 'white'
}
```



## 3. 首页

### 3.1 为异步 API 启用 Promise 功能

1. 打开 `src -> app.wpy` 文件

2. 找到 constructor() 构造函数

3. 在构造函数的最后，新增如下代码：

   ```js
   constructor() {
       super()
       this.use('requestfix')
       // 通过下面这一行代码，可以为异步的API，
       // 开启Promise功能，这样，异步API调用的结果，返回值是Promise对象
       this.use('promisify')
   }
   ```

### 3.2 轮播图数据渲染

1. 获取轮播图数据

   ```js
     // 获取轮播图数据的函数
   async getSwiperData() {
       const { data: res } = await wepy.get('/home/swiperdata')
   
       if (res.meta.status !== 200) {
         return wepy.baseToast()
       }
   
       this.swiperList = res.message
       this.$apply()
   }
   ```

2. 使用 `wepy.showToast()` 弹框提示

3. 使用 `swiper` 组件和 `swiper-item` 组件渲染轮播图效果

4. 使用 `navigator` 组件将 `images` 图片包裹起来，从而点击图片实现跳转

   ```xml
   <!-- 轮播图区域 -->
   <swiper circular indicator-dots>
     <swiper-item wx:for="{{swiperList}}" wx:key="index">
       <navigator url="{{item.navigator_url}}" open-type="{{item.open_type}}">
         <image src="{{item.image_src}}" />
       </navigator>
     </swiper-item>
   </swiper>
   ```

5. 设置 `swiper` 组件的高度为 `350rpx` 从而实现轮播图在不同屏幕的自适应

   ```less
   swiper {
     height: 350rpx;
     navigator,
     image {
       height: 100%;
       width: 750rpx;
     }
   }
   ```

### 3.3 获取首页分类选项数据

```js
  // 获取首页分类相关的数据项
async getCateItems() {
    const { data: res } = await wepy.get('/home/catitems')

    if (res.meta.status !== 200) {
      return wepy.baseToast()
    }

    this.cateItems = res.message
    this.$apply()
}
```

### 3.4 渲染分类数据项对应的UI结构

```xml
<!-- 分类区域 -->
<view class="cates">
  <block wx:for="{{cateItems}}" wx:key="index">
    <navigator url="/pages/tabs/cates" open-type="{{item.open_type}}" wx:if="{{item.navigator_url !== undefined}}" hover-class="none">
      <image src="{{item.image_src}}" />
    </navigator> 

    <image src="{{item.image_src}}" wx:else/>
  </block>
</view>
```

### 3.5 美化分类数据项的UI显示效果

```less
.cates {
  display: flex;
  justify-content: space-around;
  margin: 40rpx 0;
  image {
    width: 128rpx;
    height: 140rpx;
  }
}
```

### 3.6 获取楼层相关的数据

```js
onLoad() {
    this.getSwiperData()
    this.getCateItems()
    // 在页面加载完成后，自动获取楼层数据
    this.getFloorData()
}

// 获取楼层相关的数据
async getFloorData() {
    const { data: res } = await wepy.get('/home/floordata')

    if (res.meta.status !== 200) {
      return wepy.baseToast()
    }

    this.floorData = res.message
    // 通知页面，data中数据发生了变化，需要强制页面重新渲染一次
    this.$apply()
}
```

### 3.7 渲染楼层UI结构

```xml
<!-- 楼层区域 -->
<view class="floor-container">
  <view class="floor-item" wx:for="{{floorData}}" wx:key="index">
    <!-- 楼层的标题 -->
    <image class="floor-item-title" src="{{item.floor_title.image_src}}"/>
    <!-- 楼层的图片 -->
    <view class="floor-img-box">
      <image class="floor-item-pic" wx:for="{{item.product_list}}" wx:key="index" src="{{item.image_src}}" style="width: {{item.image_width}}rpx;" @tap="goGoodsList({{item.navigator_url}})"/>
    </view>
  </view>
</view>
```

### 3.8 美化楼层UI结构

```less
.floor-container {
  .floor-item {
    .floor-item-title {
      height: 50rpx;
      width: 640rpx;
      display: block;
    }
    .floor-img-box {
      .floor-item-pic {
        float: left;
        height: 190rpx;
        margin: 8rpx;
        margin-top: 0;
        &:nth-child(1) {
          height: 390rpx;
        }
      }
    }
  }
}
```

### 3.9 点击楼层图片跳转到商品列表页面

```js
methods = {
    // 点击楼层中的每一张图片，都要跳转到商品列表页面
    goGoodsList(url) {
      wepy.navigateTo({
        url
      })
    }
}
```



## 4. 优化

### 4.1 把页面的业务逻辑抽离到单独的 `mixin` 文件中

为了精简每个小程序页面的代码，可以将 script 中的业务逻辑，抽离到对应的 mixin 文件中，具体步骤：

1. 在 `src -> mixins` 文件夹中，新建与页面路径对应的 `.js` 文件，并初始化基本的代码结构如下：

   ```js
   import wepy from 'wepy'
   
   // 注意，必须继承自 wepy.mixin
   export default class extends wepy.mixin {}
   ```

2. 在对应的页面中，可以导入并使用对应的 mixin，具体代码如下：

   ```js
   <script>
   import wepy from 'wepy'
   // 1. 导入外界的 mixin 文件，并接受
   // @ 就代表 src 这一层路径
   import mix from '@/mixins/tabs/home.js'
   
   export default class extends wepy.page {
     // 2. 把导入的 mix 对象，挂载到 mixins 这个数据中就行
     mixins = [mix]
   }
   </script>
   ```

### 4.2 封装 `baseToast` 函数提示错误消息

1. 为了提高项目的维护性、可用性、扩展性，可以将常用的 js 逻辑，封装到 `src -> baseAPI.js` 文件中：

   ```js
   import wepy from 'wepy'
   
   /**
    * 弹框提示一个无图标的 Toast 消息
    * @str 要提示的消息内容
    */
   wepy.baseToast = function(str = '获取数据失败！') {
     wepy.showToast({
       title: str,
       // 弹框期间不会携带任何图标
       icon: 'none',
       duration: 1500
     })
   }
   ```

2. 在 `app.wpy` 中导入执行 `baseAPI.js` 文件中的代码：

   ```js
   <script>
       import wepy from 'wepy'
       import 'wepy-async-function'
       // 导入并执行 baseAPI.js 中的所有代码
       import '@/baseAPI.js'
   </script>
   ```

### 4.3 封装 `wepy.get` 函数发起get请求

在小程序项目中，需要经常发起数据请求，因此，可以将 `wepy.request()` 函数封装，在全局挂在 `wepy.get()` 函数，从而发起 Get 请求，代码如下：

```js
// src/baseAPI.js

import wepy from 'wepy'

// 请求根路径
const baseURL = 'https://www.zhengzhicheng.cn/api/public/v1'

/**
 * 发起 get 请求的 API
 * @url 请求的地址，为相对路径，必须以 / 开头
 * @data 请求的参数对象
 */
wepy.get = function(url, data = {}) {
  return wepy.request({
    url: baseURL + url,
    method: 'GET',
    data
  })
}
```

### 4.4 封装 `wepy.post` 函数发起get请求

在小程序项目中，需要经常发起数据请求，因此，可以将 `wepy.request()` 函数封装，在全局挂在 `wepy.post()` 函数，从而发起 Post 请求，代码如下：

```js
// src/baseAPI.js

import wepy from 'wepy'

// 请求根路径
const baseURL = 'https://www.zhengzhicheng.cn/api/public/v1'

/**
 * 发起 post 请求的 API
 * @url 请求的地址，为相对路径，必须以 / 开头
 * @data 请求的参数对象
 */
wepy.post = function (url, data = {}) {  
  return wepy.request({
    url: baseURL + url,
    method: 'POST',
    data
  })
}
```



## 5. 分类页面

### 5.1 自定义分类页面的编译模式

1. 点击工具栏中，编译模式的下拉菜单，选择新建编译模式
2. 填写编译模式的名称
3. 选择启动页面的路径
4. 确认添加

### 5.2 获取分类数据列表

```js
async getCateList() {
    const { data: res } = await wepy.get('/categories')

    if (res.meta.status !== 200) {
      return wepy.baseToast()
    }

    this.cateList = res.message
    this.secondCate = res.message[0].children
    this.$apply()
}
```

### 5.3 下载并安装 `vant` 小程序UI组件库

1. 访问 `vant-weapp` 的 Github 主页 https://github.com/youzan/vant-weapp
2. 点击 `Clone or Download` 按钮
3. 选择 `Download ZIP`
4. 解压下载的 `vant-weapp-dev.zip`
5. 进入解压后的目录，将 `lib` 目录重命名为 `vant`
6. 把重命名为 `vant` 的目录，复制到 `src -> assets` 目录中

### 5.4 将 vant 中的徽章组件注册为全局组件

1. 打开 `app.wpy` 文件

2. 在 `config` 节点内，新增 `usingComponents` 节点，具体代码如下：

   ```js
   config = {
       // 引用并注册全局组件
       usingComponents: {
         // 徽章组件
         'van-badge': './assets/vant/badge/index',
         'van-badge-group': './assets/vant/badge-group/index'
       }
   }
   ```

### 5.5 渲染左侧的一级分类列表结构

```xml
<van-badge-group active="{{ active }}" bind:change="onChange">
    <van-badge title="{{item.cat_name}}" wx:for="{{cateList}}" wx:key="index" />
</van-badge-group>
```

### 5.6 使用 `scroll-view` 优化左侧分类的滚动效果

```xml
<!-- 左侧的滚动视图区域 -->
<scroll-view class="left" scroll-y style="height: 200px;">
  <van-badge-group active="{{ active }}" bind:change="onChange">
    <van-badge title="{{item.cat_name}}" wx:for="{{cateList}}" wx:key="index" />
  </van-badge-group>
</scroll-view>
```

### 5.7 动态获取窗口的可用高度

```js
onLoad() {
    // 动态获取屏幕可用的高度
    this.getWindowHeight()
    this.getCateList()
}
  
    // 动态获取屏幕可用的高度
async getWindowHeight() {
    const res = await wepy.getSystemInfo()
    if (res.errMsg === 'getSystemInfo:ok') {
      this.wh = res.windowHeight
      this.$apply()
    }
}
```

### 5.8 根据一级分类的变化动态切换二级分类数据

```js
  methods = {
    onChange(e) {
      // e.detail 是点击项的索引
      // console.log(e.detail)
      this.secondCate = this.cateList[e.detail].children
    }
  }
```

### 5.9 渲染二级和三级分类的UI结构

```xml
<!-- 右侧滚动视图区域 -->
<scroll-view class="right" scroll-y style="height: {{wh}}px;">
  <!-- 循环创建二级分类 -->
  <block wx:for="{{secondCate}}" wx:key="index">
    <van-row>
      <van-col span="24" style="text-align:center;">
        <text class="cate_title" space="ensp">/  {{item.cat_name}}  /</text>
      </van-col>
    </van-row>
    <!-- 三级分类 -->
    <van-row>
      <block wx:for="{{item.children}}" wx:key="index">
        <van-col span="8" class="cell" @tap="goGoodsList({{item.cat_id}})">
          <image src="{{item.cat_icon}}" class="thumbImg" />
          <view class="thumbTitle">{{item.cat_name}}</view>
        </van-col>
      </block>
    </van-row>
  </block>
</scroll-view>
```

### 5.10 点击三级分类跳转到商品列表页面

```js
  methods = {
    // 点击跳转到商品列表页面，同时把商品分类的 cid 传递过去
    goGoodsList(cid) {
      wepy.navigateTo({
        url: '/pages/goods_list?cid=' + cid
      })
    }
  }
```



## 6. interceptor 拦截器

### 6.1 介绍 wepy 中的拦截器

可以使用WePY提供的全局拦截器对原生API的请求进行拦截。

具体方法是配置API的config、fail、success、complete回调函数。参考示例：

```js
import wepy from 'wepy';

export default class extends wepy.app {
    constructor () {
        // this is not allowed before super()
        super();
        // 拦截request请求
        this.intercept('request', {
            // 发出请求时的回调函数
            config (p) {
                // 对所有request请求中的OBJECT参数对象统一附加时间戳属性
                p.timestamp = +new Date();
                console.log('config request: ', p);
                // 必须返回OBJECT参数对象，否则无法发送请求到服务端
                return p;
            },

            // 请求成功后的回调函数
            success (p) {
                // 可以在这里对收到的响应数据对象进行加工处理
                console.log('request success: ', p);
                // 必须返回响应数据对象，否则后续无法对响应数据进行处理
                return p;
            },

            //请求失败后的回调函数
            fail (p) {
                console.log('request fail: ', p);
                // 必须返回响应数据对象，否则后续无法对响应数据进行处理
                return p;
            },

            // 请求完成时的回调函数(请求成功或失败都会被执行)
            complete (p) {
                console.log('request complete: ', p);
            }
        });
    }
}
```

### 6.2 实现数据加载期间的loading效果

打开 `app.wpy`，在 `constructor()` 构造函数中，通过拦截器实现loading效果，具体代码如下：

```js
constructor() {
    super()
    this.use('requestfix')
    // 通过这一行代码，可以为异步的API，开启Promise功能，这样，异步API调用的结果，返回值是Promise对象
    this.use('promisify')

    // 拦截器
    this.intercept('request', {
      // 发出请求时的回调函数
      config(p) {
        // 显示loading效果
        wepy.showLoading({
          title: '数据加载中...'
        })
        // 必须返回OBJECT参数对象，否则无法发送请求到服务端
        return p
      },

      // 请求成功后的回调函数
      success(p) {
        // 必须返回响应数据对象，否则后续无法对响应数据进行处理
        return p
      },

      // 请求失败后的回调函数
      fail(p) {
        // 必须返回响应数据对象，否则后续无法对响应数据进行处理
        return p
      },

      // 请求完成时的回调函数(请求成功或失败都会被执行)
      complete(p) {
        // 隐藏loading效果
        wepy.hideLoading()
      }
    })
}
```



## 7. 搜索

### 7.1 全局注册搜索组件并渲染到页面中

1. 在 `app.wpy` 中的 `config` 节点中，找到 `usingComponents` 并注册搜索组件，代码如下：

   ```js
   export default class extends wepy.app {
     config = {
         // 引用并注册全局组件
         usingComponents: {
             // 商品卡片组件
             'van-card': './assets/vant/card/index'
         }
     }
   ```

2. 在 `search.wpy` 中使用刚才注册的组件：

   ```xml
   <!-- 搜索框区域 -->
   <van-search value="{{ value }}" placeholder="请输入搜索关键词" show-action bind:change="onChange" bind:search="onSearch" bind:cancel="onCancel" />
   ```

### 7.2 根据关键字的变化动态获取搜索建议列表数据

1. 监听搜索框组件的 `bind:change="onChange"` 事件：

   ```js
   // 当搜索关键词发生变化，会触发这个事件处理函数
   onChange(e) {
         // e.detail 是变化过后最新的内容
         console.log(e.detail)
         this.getSuggestList(e.detail)
   }
   ```

2. 定义 `getSuggestList()` 函数获取搜索建议列表：

   ```js
   // 获取搜索建议列表
   async getSuggestList(searchStr) {
       const { data: res } = await wepy.get('/goods/qsearch', { query: searchStr })
   
       if (res.meta.status !== 200) {
         return wepy.baseToast()
       }
   
       this.suggestList = res.message
       this.$apply()
   }
   ```

### 7.3 解决搜索关键字为空时候的小Bug

产生 Bug 的原因，是因为用户输入关键词的 length 长度导致的，因此，可以适当修改 `onChange` 事件处理函数如下：

```js
// 当搜索关键词发生变化，会触发这个事件处理函数
onChange(e) {
      // e.detail 是变化过后最新的内容
      console.log(e.detail)
      if (e.detail.trim().length <= 0) {
        this.suggestList = []
        return
      }
      this.getSuggestList(e.detail)
}
```

### 7.4 通过Cell单元格组件渲染搜索建议列表的UI结构

1. 全局注册 `cell` 单元格相关的组件：

   ```js
   export default class extends wepy.app {
     config = {
         // 引用并注册全局组件
         usingComponents: {
             // 单元格组件
             'van-cell': './assets/vant/cell/index',
             'van-cell-group': './assets/vant/cell-group/index'
         }
     }
   ```

2. 在 `search.wpy` 页面中渲染搜索建议列表结构：

   ```xml
   <!-- 搜索的建议列表 -->
   <van-cell-group>
     <block wx:for="{{suggestList}}" wx:key="index">
       <van-cell title="{{item.goods_name}}" />
     </block>
   </van-cell-group>
   ```

### 7.5 点击搜索建议项导航到商品详情页

1. 为 `vant-cell` 组件绑定点击事件处理函数：

   ```xml
   <van-cell title="{{item.goods_name}}" @tap="goGoodsDetail({{item.goods_id}})" />
   ```

2. 定义事件处理函数，并导航到详情页面：

   ```js
   methods = {
       // ...
       // 点击搜索建议项，导航到商品详情页面
       goGoodsDetail(goods_id) {
         wepy.navigateTo({
           url: '/pages/goods_detail/main?goods_id=' + goods_id
         })
       }
   }
   ```

### 7.6 触发搜索事件后导航到商品列表页面

1. 监听 `vant-search` 组件的 `bind:search="onSearch"` 事件

2. 导航到商品详情页面：

   ```js
   // 触发了搜索
   onSearch(e) {
         // e.detail 就是最新的搜索关键字
         const kw = e.detail.trim()
         // 如果搜索关键词为空，则阻止跳转
         if (kw.length <= 0) {
           return
         }
         wepy.navigateTo({
           url: '/pages/goods_list?query=' + kw
         })
   }
   ```

### 7.7 页面加载期间读取搜索关键词列表

```js
  onLoad() {
    // 调用小程序官方提供的 getStorageSync 函数，可以从本地存储中读取数据
    const kwList = wx.getStorageSync('kw') || []
    // 将读取的数据挂载到 data 中
    this.kwList = kwList
  }
```

### 7.8 将关键词存储到Storage中

```js
// 触发了搜索
onSearch(e) {
      // e.detail 就是最新的搜索关键字
      const kw = e.detail.trim()
      if (kw.length <= 0) {
        return
      }

      // 把用户填写的搜索关键词，保存到 Storage 中
      if (this.kwList.indexOf(kw) === -1) {
        this.kwList.unshift(kw)
      }
      // 数组的 slice 方法，不会修改原数组，而是返回一个新的数组
      this.kwList = this.kwList.slice(0, 10)
      wepy.setStorageSync('kw', this.kwList)

      wepy.navigateTo({
        url: '/pages/goods_list?query=' + kw
      })
}
```

### 7.9 定义计算属性来决定是否展示历史搜索区域

```js
// 计算属性
computed = {
    // true 展示搜索历史区域
    // false 展示搜索建议区域
    isShowHistory() {
      if (this.value.length <= 0) {
        return true
      }
      return false
    }
}
```

### 7.10 绘制历史搜索头部区域的UI结构

1. 全局注册 `vant-icon` 组件：

   ```js
   export default class extends wepy.app {
     config = {
         // 引用并注册全局组件
         usingComponents: {
             // 图标
             'van-icon': './assets/vant/icon/index'
         }
     }
   ```

2. 定义历史搜索头部区域的UI结构：

   ```xml
   <!-- 历史搜索区域 -->
   <view wx:else>
     <view class="history_title">
       <text>历史搜索</text>
       <van-icon name="delete" @tap="clearHistory" />
     </view>
   </view>
   ```

2. 定义样式美化对应的UI结构：

   ```less
   .history_title {
     display: flex;
     justify-content: space-between;
     padding: 0 20rpx;
     text:nth-child(1) {
       font-size: 26rpx;
       font-weight: bold;
     }
   }
   ```

### 7.11 渲染历史搜索列表的UI结构

1. 全局注册 `vant-tag` 组件：

   ```js
   export default class extends wepy.app {
     config = {
         // 引用并注册全局组件
         usingComponents: {
             // Tag 标签
             'van-tag': './assets/vant/tag/index'
         }
     }
   ```

2. 通过循环渲染历史搜索列表的UI结构：

   ```xml
   <!-- 历史搜索区域 -->
   <view wx:else>
     <view class="history_title">
       <text>历史搜索</text>
       <van-icon name="delete" @tap="clearHistory" />
     </view>
     <view class="history_body">
       <van-tag size="large" wx:for="{{kwList}}" wx:key="index" class="tag" @tap="goGoodsList({{item}})">{{item}}</van-tag>
     </view>
   </view>
   ```

2. 通过样式美化 `vant-tag` 组件的样式：

   ```less
   .tag {
     > view {
       margin: 15rpx;
     }
   }
   ```



## 8. 商品列表

### 8.1 处理请求参数

1. 在 `goods_list.js` 中定义 `data` 节点，并定义对应的请求参数：

   ```js
   data = {
       // 查询关键词
       query: '',
       // 商品分类的Id
       cid: '',
       // 页码值
       pagenum: 1,
       // 每页显示多少条数据
       pagesize: 10
   }
   ```

2. 在 `onLoad()` 生命周期函数中，处理 `query` 和 `cid` 的值，并发起数据请求：

   ```js
   onLoad(options) {
       this.query = options.query || ''
       this.cid = options.cid || ''
       this.getGoodsList()
   }
   ```

### 8.2 获取商品列表数据

```js
// 获取商品列表数据
async getGoodsList(cb) {
    const { data: res } = await wepy.get('/goods/search', {
      query: this.query,
      cid: this.cid,
      pagenum: this.pagenum,
      pagesize: this.pagesize
    })

    if (res.meta.status !== 200) {
      return wepy.baseToast()
    }

    this.goodslist = res.message.goods
    this.total = res.message.total
    this.$apply()
}
```

### 8.3 循环渲染商品列表的UI结构

1. 全局注册 `vant-card` 组件：

   ```js
   export default class extends wepy.app {
     config = {
         // 引用并注册全局组件
         usingComponents: {
             // 商品卡片组件
             'van-card': './assets/vant/card/index'
         }
     }
   ```

2. 循环渲染商品列表对应的UI结构：

   ```xml
   <!-- 商品列表区域 -->
   <block wx:for="{{goodslist}}" wx:key="index">
     <van-card num="{{item.goods_number}}" price="{{item.goods_price}}" title="{{item.goods_name}}" thumb="{{ item.goods_small_logo }}" />
     <!-- 分割线 -->
     <view class="sep_line"></view>
   </block>
   ```

3. 美化分割线的样式：

   ```less
   .sep_line {
     border-top: 1rpx solid #eee;
   }
   ```

### 8.4 初步实现上拉加载更多的操作

1. 在 `goods_list.wpy` 中配置上拉加载更多的距离：

   ```js
   <script>
   import wepy from 'wepy'
   import mix from '@/mixins/goods_list.js'
   
   export default class extends wepy.page {
     // 注意：config 节点只能写到页面的JS中，不能抽离到 mixin 中
     config = {
       navigationBarTitleText: '商品列表',
       // 上拉触底的距离，默认是 50px
       onReachBottomDistance: 100
     }
   
     mixins = [mix]
   }
   </script>
   ```

2. 在 `goods_list.js` 中监听上拉触底的事件：

   ```js
   // 触底操作
   onReachBottom() {
       console.log('触底了')
       this.pagenum++
       this.getGoodsList()
   }
   ```

3. 新旧数据拼接合并：

   ```js
   // 获取商品列表数据
     async getGoodsList(cb) {
       // ...
       this.goodslist = [...this.goodslist, ...res.message.goods]
       // ...
     }
   ```

### 8.5 通过公式判断列表数据是否全部加载完毕

1. 判断数据是否加载完毕的公式为：

   ```js
   当前页码值 * 每页显示的数据条数 >= 总数据条数
   pagemun * pagesize >= total
   ```

2. 优化 `onReachBottom()` 函数的业务处理逻辑：

   ```js
   // 触底操作
   onReachBottom() {
       // 先判断是否有下一页的数据
       if (this.pagenum * this.pagesize >= this.total) {
         return
       }
       console.log('触底了')
       this.pagenum++
       this.getGoodsList()
   }
   ```

### 8.6 通过 `isover` 控制数据加载完毕后的提示消息

1. 在 data 中定义 `isover` 布尔值：

   ```js
   data = {
       // ...
       // 数据是否加载完毕的布尔值，默认为 false
       isover: false
   }
   ```

2. 当所有数据加载完毕之后，把 `isover` 的值重置为 `true`：

   ```js
   if (this.pagenum * this.pagesize >= this.total) {
         this.isover = true
         return
   }
   ```

3. 在页面上，渲染数据加载完毕之后的UI结构，并通过 `isover` 控制其显示与隐藏：

   ```xml
   <!-- 数据加载完毕后的提示消息 -->
   <view class="over_line" hidden="{{!isover}}">-------- 我是有底线的 --------</view>
   ```

4. 美化 `over_line` 的样式：

   ```less
   .over_line {
     font-size: 24rpx;
     text-align: center;
     height: 60rpx;
     line-height: 60rpx;
     color: #ddd;
   }
   ```

### 8.7 通过 `isloading` 防止重复发起数据请求

1. 在 data 中定义 `isloading` 布尔值：

   ```js
   data = {
       // ...
       // 表示当前数据是否正在请求中
       isloading: false
   }
   ```

2. 优化 `getGoodsList()` 函数：

   ```js
   // 获取商品列表数据
   async getGoodsList(cb) {
       // 即将发起请求时，将 isloading 重置为 true
       this.isloading = true
       const { data: res } = await wepy.get('/goods/search', {
         query: this.query,
         cid: this.cid,
         pagenum: this.pagenum,
         pagesize: this.pagesize
       })
   
       if (res.meta.status !== 200) {
         return wepy.baseToast()
       }
   
       this.goodslist = [...this.goodslist, ...res.message.goods]
       this.total = res.message.total
       // 当数据请求完成后，将 isloading 重置为 false
       this.isloading = false
       this.$apply()
   }
   ```

3. 优化 `onReachBottom()` 函数：

   ```js
   // 触底操作
   onReachBottom() {
       // 判断当前是否正在请求数据中，
       // 如果 isloading 值为 true，则 return 从而终止后续操作，防止重复发起数据请求
       if (this.isloading) {
         return
       }
       // ...
   }
   ```

### 8.8 下拉刷新

1. 在 `goods_list.wpy` 中启用 `下拉刷新` 和设置 `下拉刷新窗口的背景色` ：

   ```js
   export default class extends wepy.page {
     // 注意：config 节点只能写到页面的JS中，不能抽离到 mixin 中
     config = {
       // ...
   
       // 开启下拉刷新
       enablePullDownRefresh: true,
       // 设置下拉刷新窗口的背景色
       backgroundColor: '#eee'
     }
   
     mixins = [mix]
   }
   </script>
   ```

2. 在 `goods_list.js` 中监听下拉刷新的事件处理函数：

   ```js
   // 下拉刷新的操作
   onPullDownRefresh() {
       // 初始化必要的字段值
       this.pagenum = 1
       this.total = 0
       this.goodslist = []
       this.isover = this.isloading = false
   
       // 重新发起数据请求
       this.getGoodsList()
   }
   ```

3. 在 `getGoodsList()` 函数中，当数据请求完成后，手动调用API关闭下拉刷新效果：

   ```js
     // 获取商品列表数据
     async getGoodsList(cb) {
   	// ...
   
       this.goodslist = [...this.goodslist, ...res.message.goods]
       this.total = res.message.total
       this.isloading = false
       this.$apply()
       // 当数据请求成功后，立即关闭下拉刷新效果
       wepy.stopPullDownRefresh()
     }
   ```

### 8.9 通过 callback 回调函数优化关闭下拉刷新的行为

1. 优化 `onPullDownRefresh` 中的代码，在调用 `getGoodsList()` 函数时，把停止下拉刷新的代码，以回调函数的形式传递进去，示例代码如下：

   ```js
     // 下拉刷新的操作
     onPullDownRefresh() {
       // 初始化必要的字段值
       this.pagenum = 1
       this.total = 0
       this.goodslist = []
       this.isover = this.isloading = false
   
       // 重新发起数据请求
       this.getGoodsList(() => {
         // 停止下拉刷新的行为
         wepy.stopPullDownRefresh()
       })
     }
   ```

2. 优化 `stopPullDownRefresh()` 中的代码如下：

   ```js
     // 获取商品列表数据
     async getGoodsList(cb) {
   	// ...
       this.$apply()
       // 只有当外界传递了 cb 回调函数之后，才调用 cb()
       cb && cb()
     }
   ```

### 8.10 点击商品列表Item项导航到商品详情页

1. 为商品列表中的每个 Item 项绑定点击事件处理函数：

   ```js
   <van-card @tap="goGoodsDetail({{item.goods_id}})" />
   ```

2. 定义事件处理函数，导航到商品详情页面：

   ```js
   methods = {
       // 点击跳转到商品详情页面
       goGoodsDetail(goods_id) {
         wepy.navigateTo({
           url: '/pages/goods_detail/main?goods_id=' + goods_id
         })
       }
   }
   ```

